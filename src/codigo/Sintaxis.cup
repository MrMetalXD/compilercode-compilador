package codigo;
import java_cup.runtime.Symbol;

parser code {:
    public static TablaSimbolos tabla;
    private Symbol s;
    private java.util.List<String> errores = new java.util.ArrayList<>();
    private java_cup.runtime.Scanner scanner;
    private javax.swing.JTextPane jErrorArea;

    // ---- CONSTRUCTOR QUE SI SE USA ----
    public Sintaxis(java_cup.runtime.Scanner s, javax.swing.JTextPane area, TablaSimbolos t){
        super(s);           // llama al parser de CUP
        this.scanner = s;   // guarda el scanner
        this.jErrorArea = area;   // guarda tu JTextPane
        Sintaxis.tabla = t; //tabla compartida entre el lexico y sintactico

    }

    public Symbol getS(){ 
        return this.s; 
    }
    
    public java.util.List<String> getErrores(){ 
        return this.errores; 
    }
    
    private void escribirJErrorArea(final String mensaje) {
        if (jErrorArea == null) return;
        javax.swing.SwingUtilities.invokeLater(() -> {
            try {
                javax.swing.text.StyledDocument doc = jErrorArea.getStyledDocument();
                doc.insertString(doc.getLength(), mensaje + "\n", null);
                jErrorArea.setCaretPosition(doc.getLength());
            } catch (Exception ex) {
                System.err.println("Error al escribir en jErrorArea: " + ex);
            }
            });

    }
    
    private void registrarError(String mensaje) {
        errores.add(mensaje);
        System.err.println(mensaje);   // Rojo en consola de NetBeans
        escribirJErrorArea(mensaje); // Texto en tu JTextPane
    }


    private String obtenerSugerencia(Symbol token) {
        if (token == null) return "Archivo incompleto.";
        
        switch (token.sym) {
            case sym.PUNTO_COMA:   
                return "Falta una instruccion antes del ';' o hay un ';' de más.";
            case sym.COMA:   
                return "Coma mal colocada o falta otro elemento en la lista.";
            case sym.DOS_PUNTOS:   
                return "Falta una lista despues de ':' por ejemplo (terminales: A,B,C).";    
            case sym.OPE_ASIGNACION:   
                return "Asignación incompleta: falta una expresion a la derecha o un identificador a la izquierda."; 
            case sym.PAREN_ABRE:   
                return "Falta expresión o condición despues de '('";
            case sym.PAREN_CIERRA: 
                return "Parentesis de cierre sin apertura o falta algo antes de ')'";
            case sym.LLAVE_ABRE: 
                return "Llave '{' inesperada, revisa si falta una palabra reservada o cabecera antes del bloque"; 
            case sym.LLAVE_CIERRA: 
                return "Llave '}' inesperada, Posible bloque vacío o falta cerrar una instrucción anterior.";

            case sym.ID:           
                return "Identificador inesperado, falta un operador o palabra reservada antes.";
            case sym.NUMERO:       
                return "Número inesperado, revisa la expresión o asignación.";
            case sym.CADENA:
                return "Cadena inesperada, revisa si el token/lugar acepta la cadena.";

            case sym.SI:
                return "Estructura 'si' mal formada, revisa condición y bloque.";
            case sym.SINO:         
                return "El 'sino' debe ir despues de un 'si'.";
            case sym.FIN_SI:       
                return "Cierre 'fin_si' sin un 'si' previo";
            case sym.MIENTRAS:
                return "Estructura 'mientras' mal formada, revisa condición y bloque.";
            case sym.FIN_MIENTRAS:
                return "Cierre 'fin_mientras' sin un 'mientras' previo.";

            case sym.COMPILAR:
                return "Error en la cabecera 'compilar': revisa nombre y llaves.";
            case sym.SECCION:
                return "Sección mal declarada: revisa 'seccion <nombre> { ... }'.";
            case sym.ANALISIS_LEXICO:
                return "Error dentro de la sección 'analisis_lexico'.";
            case sym.ANALISIS_SINTACTICO:
                return "Error dentro de la sección 'analisis_sintactico'.";
            case sym.PRINCIPAL:
                return "Error dentro de la sección 'principal'.";

            case sym.EOF:          
                return "El archivo terminó antes de cerrar una estructura, falta un '}' o una sección.";
            default:               
                return "Revisa la estructura anterior a esta instruccion.";
        }
    }
    
    public void syntax_error(Symbol tokenActual){
        this.s = tokenActual;

        String valorToken = (tokenActual == null || tokenActual.value == null) ? "<EOF>" : cur_token.value.toString();
        int linea = (tokenActual == null) ? -1 : (tokenActual.left + 1);
        int columna  = (tokenActual == null) ? -1 : (tokenActual.right +1);
        
        // Obtener que se esperaba
        String sugerencia = obtenerSugerencia(tokenActual);

        String errorMsj = String.format("Error Sintáctico en la Línea %d, Columna %d: Se encontró \"%s\". Sugerencia: [%s].", 
                                        linea, columna, valorToken, sugerencia);
      
        // Registramos el error
        registrarError(errorMsj);      
        
        //Recuperacion de errores (MODO PANICO)
        try {
            if (tokenActual == null || tokenActual.sym == sym.EOF) return;
            java_cup.runtime.Symbol t;

            while(true) {
                t = scanner.next_token();
                if (t == null || t.sym == sym.EOF) break;
                
                if(t.sym == sym.PUNTO_COMA || t.sym == sym.LLAVE_CIERRA) {
                    break;
                }
            }

        } catch (Exception e){
             registrarError("Error durante recuperación de errores sintácticos: " + e.getMessage());
        }
    }
:}


/* TERMINALES */
terminal COMPILAR, SECCION, ANALISIS_LEXICO, ANALISIS_SINTACTICO, PRINCIPAL,SI, SINO, FIN_SI, MIENTRAS, FIN_MIENTRAS,
DEFINIR_ALFABETO, CONJUNTO, DEFINIR_TOKENS, PALABRAS_RESERVADAS, EJECUTAR_AUTOMATA, ESTADOS, ESTADO_INICIAL, ESTADOS_FINALES, 
TRANSICIONES, OTRO, TABLA_SIMBOLOS, ESTRUCTURA_TABLA, CAMPO, TABLA, GENERAR_TS,CONSTRUIR_TABLA, ENTRADA, 
IMPRIMIR, ARBOL, TOKENS, TOKEN,TERMINALES, DIBUJAR, CARGAR_ARCHIVO, VERIFICAR_ERRORES, VER_ERRORES, LIMPIAR_ERRORES, LINEA, COLUMNA, OPE_ASIGNACION, 
OPE_ARITMETICO, OPE_RELACIONAL, OPE_LOGICO, LLAVE_ABRE, LLAVE_CIERRA, PAREN_ABRE, PAREN_CIERRA,COMA, DOS_PUNTOS, 
PUNTO_COMA, CORCHETE_ABRE, CORCHETE_CIERRA, OPE_TRANSICION, ID, CADENA, NUMERO, NO_TERMINALES, VACIO, REGLA, INICIO, EJECUTARPROG;

/* NO TERMINALES */
non terminal programa, lista_secciones, seccion, seccion_lexico, lista_declaracion_lex, declaracion_lex,
def_alfabeto, lista_conjuntos, conjunto_decl, def_tokens, lista_decl_tokens, decl_token, decl_pal_res, def_automata, 
lista_decl_automata, decl_automata, lista_estados, lista_estados_finales, estado_final, lista_elementos, seccion_sintactico, 
lista_declaracion_sintac, declaracion_sintac, ids_terminales, ids_noterminales, ids_campo, seccion_principal, 
instrucciones, instruccion, asignacion, funcion,condicion_si, ciclo_mientras, llamada_reservada, condicion, 
expresion, producciones, seccion_tabla,contenido_tabla, decl_tabla, exp_llamada, instrucciones_tabla, 
instruccion_tabla, bloque_construir, lista_transiciones, transicion, entrada_transicion, llamada_metodo, argumentos;

precedence left OPE_LOGICO;
precedence left OPE_RELACIONAL;
precedence left OPE_ARITMETICO;


start with programa;

/* ESTRUCTURA GENERAL DEL PROGRAMA */

programa ::= COMPILAR ID:id LLAVE_ABRE lista_secciones LLAVE_CIERRA EJECUTARPROG ID PUNTO_COMA
{:
    parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
    parser.tabla.asignarTipoyDireccion((String)id, "PROGRAMA");
:};

lista_secciones ::= lista_secciones seccion | seccion ;

seccion ::= seccion_lexico | seccion_sintactico | seccion_principal | seccion_tabla;

/* SECCION ANALISIS_LEXICO  */

seccion_lexico ::= SECCION ANALISIS_LEXICO LLAVE_ABRE lista_declaracion_lex LLAVE_CIERRA;

lista_declaracion_lex ::= lista_declaracion_lex declaracion_lex | declaracion_lex;

declaracion_lex ::= def_alfabeto | def_tokens | def_automata;

def_alfabeto ::= DEFINIR_ALFABETO LLAVE_ABRE lista_conjuntos LLAVE_CIERRA;

lista_conjuntos ::= lista_conjuntos conjunto_decl | conjunto_decl;

conjunto_decl ::= CONJUNTO ID:id OPE_ASIGNACION CORCHETE_ABRE lista_elementos CORCHETE_CIERRA PUNTO_COMA
{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "CONJUNTO");
:};

lista_elementos ::= CADENA | lista_elementos COMA CADENA;

def_tokens ::= DEFINIR_TOKENS LLAVE_ABRE lista_decl_tokens LLAVE_CIERRA;

lista_decl_tokens ::= lista_decl_tokens decl_token | decl_token | decl_pal_res;

decl_pal_res ::= PALABRAS_RESERVADAS OPE_ASIGNACION CORCHETE_ABRE lista_elementos CORCHETE_CIERRA PUNTO_COMA;

decl_token ::= TOKEN ID:id PUNTO_COMA 
{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "TOKEN");
:};

def_automata ::= EJECUTAR_AUTOMATA LLAVE_ABRE lista_decl_automata LLAVE_CIERRA;

lista_decl_automata ::= lista_decl_automata decl_automata | decl_automata;

decl_automata ::= ESTADOS DOS_PUNTOS lista_estados PUNTO_COMA | ESTADO_INICIAL DOS_PUNTOS ID PUNTO_COMA 
     | ESTADOS_FINALES DOS_PUNTOS CORCHETE_ABRE lista_estados_finales CORCHETE_CIERRA PUNTO_COMA
    | TRANSICIONES LLAVE_ABRE lista_transiciones LLAVE_CIERRA;

lista_estados ::= ID:id 
{:
  Sintaxis.tabla.registrarIdentificador((String)id,idleft+1,idright+1);
  Sintaxis.tabla.asignarTipoyDireccion((String)id,"ESTADO");
:}
| lista_estados COMA ID:id
{:
  Sintaxis.tabla.registrarIdentificador((String)id,idleft+1,idright+1);
  Sintaxis.tabla.asignarTipoyDireccion((String)id,"ESTADO");
:};

lista_estados_finales ::= estado_final | lista_estados_finales COMA estado_final;

estado_final ::= ID OPE_ASIGNACION ID;

lista_transiciones ::= lista_transiciones transicion | transicion;

transicion ::= PAREN_ABRE ID COMA entrada_transicion PAREN_CIERRA OPE_TRANSICION ID PUNTO_COMA;

entrada_transicion ::= ID | CADENA | OTRO;

/* SECCION ANALISIS_SINTACTICO */

seccion_sintactico ::= SECCION ANALISIS_SINTACTICO LLAVE_ABRE lista_declaracion_sintac LLAVE_CIERRA;

lista_declaracion_sintac ::= lista_declaracion_sintac declaracion_sintac | declaracion_sintac;

declaracion_sintac ::= TERMINALES DOS_PUNTOS ids_terminales PUNTO_COMA | NO_TERMINALES DOS_PUNTOS ids_noterminales PUNTO_COMA 
    | INICIO DOS_PUNTOS ID PUNTO_COMA | REGLA ID DOS_PUNTOS producciones PUNTO_COMA | VACIO PUNTO_COMA;

producciones ::= producciones ID | ID; 

ids_terminales ::= ID | ids_terminales COMA ID;

ids_noterminales ::= ID:id
{:
  Sintaxis.tabla.registrarIdentificador((String)id,idleft+1,idright+1);
  Sintaxis.tabla.asignarTipoyDireccion((String)id,"NO_TERMINAL");
:} 
| ids_noterminales COMA ID:id
{:
  Sintaxis.tabla.registrarIdentificador((String)id,idleft+1,idright+1);
  Sintaxis.tabla.asignarTipoyDireccion((String)id,"NO_TERMINAL");
:};


/* SECCION TABLA_SIMBOLOS */

seccion_tabla ::= SECCION TABLA_SIMBOLOS LLAVE_ABRE contenido_tabla instrucciones_tabla LLAVE_CIERRA;

contenido_tabla ::= contenido_tabla decl_tabla | decl_tabla;

decl_tabla ::= ESTRUCTURA_TABLA ID:id LLAVE_ABRE CAMPO ids_campo PUNTO_COMA LLAVE_CIERRA 
{:
    parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
    parser.tabla.asignarTipoyDireccion((String)id, "ESTRUCTURA_TABLA");
:}
| TABLA ID:id PUNTO_COMA
{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "TABLA");
:};

ids_campo ::= ID:id 
{:
  Sintaxis.tabla.registrarIdentificador((String)id,idleft+1,idright+1);
  Sintaxis.tabla.asignarTipoyDireccion((String)id,"CAMPO");
:} 
| ids_campo COMA ID:id
{:
  Sintaxis.tabla.registrarIdentificador((String)id,idleft+1,idright+1);
  Sintaxis.tabla.asignarTipoyDireccion((String)id,"CAMPO");
:};

instrucciones_tabla ::= instrucciones_tabla instruccion_tabla | /* vacio */ ;

instruccion_tabla ::= CONSTRUIR_TABLA expresion LLAVE_ABRE instrucciones LLAVE_CIERRA;

/* SECCION PRINCIPAL */

seccion_principal ::= SECCION PRINCIPAL LLAVE_ABRE instrucciones LLAVE_CIERRA ;

instrucciones ::=  instrucciones instruccion | instruccion;

instruccion ::=  asignacion PUNTO_COMA | funcion PUNTO_COMA | llamada_reservada PUNTO_COMA |condicion_si | ciclo_mientras ;

asignacion ::= ID:id OPE_ASIGNACION expresion
{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "VARIABLE");
:} 
| ENTRADA ID:id OPE_ASIGNACION expresion
{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "ENTRADA");
:} 
| TOKENS ID:id OPE_ASIGNACION expresion

{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "VARIABLE_TOKENS");
:}
| ARBOL ID:id OPE_ASIGNACION expresion
{:
   parser.tabla.registrarIdentificador((String)id, idleft+1, idright+1);
   parser.tabla.asignarTipoyDireccion((String)id, "ARBOL");
:};

funcion ::= IMPRIMIR expresion | DIBUJAR expresion | VER_ERRORES expresion | LIMPIAR_ERRORES expresion;

llamada_reservada ::= CONSTRUIR_TABLA expresion;

condicion_si ::= SI PAREN_ABRE condicion PAREN_CIERRA instrucciones FIN_SI 
    | SI PAREN_ABRE condicion PAREN_CIERRA instrucciones SINO instrucciones FIN_SI;

ciclo_mientras ::= MIENTRAS PAREN_ABRE condicion PAREN_CIERRA instrucciones FIN_MIENTRAS;

condicion ::= expresion | expresion OPE_RELACIONAL expresion | expresion OPE_LOGICO expresion;

expresion ::= ID | NUMERO | CADENA | exp_llamada | llamada_metodo | expresion OPE_ARITMETICO expresion | PAREN_ABRE expresion PAREN_CIERRA;

exp_llamada ::= CARGAR_ARCHIVO expresion | VERIFICAR_ERRORES expresion | LINEA expresion | COLUMNA expresion 
| GENERAR_TS PAREN_ABRE expresion COMA expresion PAREN_CIERRA | ANALISIS_LEXICO expresion 
| ANALISIS_SINTACTICO expresion;

llamada_metodo ::= ID PAREN_ABRE argumentos PAREN_CIERRA;

argumentos ::= argumentos COMA expresion | expresion | /* vacio */ ;